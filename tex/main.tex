\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}

\usepackage{hyperref, listings, float, graphicx, amsmath, longtable, rotating}
\usepackage[square, sort, comma, numbers]{natbib}
\usepackage[nottoc]{tocbibind}
\usepackage{cleveref}
\usepackage{lipsum}
\usepackage[autostyle=true]{csquotes}

\title{SBML2SHACL}

\author{Edoardo De Matteis \\ 1746561}

\begin{document}
\maketitle
\tableofcontents

\clearpage

\section{Introduzione}

\subsection{SBML}
\textbf{Systems Biology Markup Language (SBML)} è un formato di rappresentazione basato su XML per la modellazione di processi biologici e chimici. Non è un linguaggio bensì una \textit{lingua franca} tra tool che utilizzano formati di rappresentazione differenti e ad oggi è \textit{de facto} uno standard per i modelli computazionali in biologia. 

Ai fini di questo progetto distinguiamo due differenti SBML:
\begin{itemize}
    \item \textbf{SBML Level 3}. La specifica del \textit{Core} che offre le funzionalità base di SBML, in questo documento lo si indica come "SBML 3".
    \item \textbf{Hierarchical Model Composition}. Noto come "comp" (namespace del package e quindi parola chiave necessaria in un file XML) questo package offre la possibilità di include modelli e sottomodelli uno dentro l'altro permettendo allo sviluppatore e aventuali tool di:
    \begin{enumerate}
        \item Scomporre modelli troppo grandi in modelli più piccoli per ridurne la complessità.
        \item Avere istanze multiple di un modello - precedentemente definito - all'interno di altri modelli, evitando ripetizione di codice. 
        \item Creare librerie di codice riusabile e modelli considerati corretti. 
    \end{enumerate}
    In questo documento lo si indica come "Extended SBML". 
\end{itemize}


\subsection{RDF}
Il \textbf{Resource Description Framework (RDF)} è una famiglia di specifiche definite dal World Wide Web Consortium (W3C) utilizzate per la modellazione di informazioni implementate come risorse web. RDF è simile ad altri approcci classici come database relazionali o logiche desctrittive nei quali si hanno affermazioni sulle risorse sotto forma di triple soggetto-predicato-oggetto; il soggetto è la risorsa stessa e il predicato esprime una relazione tra soggetto e oggetto.

Se ad esempio volessimo esprimere il concetto "il cielo è blu" avremo 
\begin{itemize}
    \item [] \textbf{soggetto}: "il cielo"
    \item [] \textbf{predicato}: "è di colore"
    \item [] \textbf{oggetto}: "blu"
\end{itemize}

Contrariamente ad approccio object oriented entità-attributo-valore in cui avremmo un oggetto "cielo" con attributo "colore" di valore "blu". Come si può vedere nell'\href{https://book.validatingrdf.com/bookHtml008.html}{immagine} \ref{fig:graph} un insieme di triple rappresenta intrinsecamente un grafo: una rappresentazione decisamente conveniente ma spesso nella pratica un modello RDF è mantenuto come database relazionale (chiamato Triplestores o Quad stores).

\begin{figure}[h!t]
    \caption{Un modello RDF è un grafo.}
    \label{fig:graph}
    \includegraphics[scale=0.3]{images/RDFGraph.png}
    \centering
\end{figure}

Esistono vari formati per esprimere il modello astratto RDF, in questo progetto ho scelto di utilizzare solo file Turtle (\texttt{.ttl}).

\subsection{SHACL}
\textbf{Shapes Constraint Language (SHACL)} è una specifica del W3C per la verifica di informazioni sotto forma di grafi dato un insieme di vincoli. Il processo di verifica prende in input un grafo contenente le dichiarazioni delle shape ovvero le definizioni cui i nodi, le istanze, dovranno essere verificati; in input si può avere qulsiasi formato RDF, in questo progetto si userà Turtle. 

SHACL include anche il linguaggio di query \textbf{SPARQL SPARQL Protocol and RDF Query Language (SPARQL)}.

\subsection{Obiettivi}

Lo scopo di questo progetto, sotto la guida del Professor Tronci, è quello di convertire automaticamente una specifica SBML in SHACL. A tal fine il problema è stato diviso in tre fasi:

\begin{enumerate}
    \item Modellare in SHACL un sottoinsieme dei costrutti che definiscono SBML . 
    \item Scrivere un parser che traduca una specifica SBML in SHACL.
    \item Scrivere un parser che traduca una specifica SHACL in SBML.
\end{enumerate}

Si assume a priori che i file SBML in input siano corretti, la \href{http://sbml.org/Facilities/Validator}{verifica} è eseguibile online.

\section{Modellazione}

In questa prima fase si è scelto un sottoinsieme di SBML 3.2 e i costrutti supplementari in Extended SBML e ne è stato formalizzato un modello. Nella tabella ~\ref{tab:modellazione} vengono descritti i principali costrutti, sono state volontariamente omesse entità quali \texttt{listOf*} il cui significato è intuitivo e avrebbero solo reso la tabella meno leggibile, in ogni caso è possibile consultare ulteriormente il diagramma \texttt{diagram.png}, mostrato anche in figura \ref{fig:diagram}, e il file delle shape \texttt{shapes.ttl}. È possibile verificare la consistenza di un file di nodi rispetto al modello tramite lo script \texttt{shacl\_verifier.py}.

\begin{longtable}{p{.4\textwidth}p{.5\textwidth}}
    \textbf{Entità} & \textbf{Descrizione} \\
    \hline
    \multicolumn{2}{c}{SBML 3.2} \\
    \hline
    SBase & Classe astratta superclasse di ogni altra classe. Per quanto in SBML sia considerata a tutti gli effetti un tipo, poiché non esistono attributi di tipo SBase a questa classe si riserva un trattamento differente rispetto ai tipi composti quali ID, SId, etc \dots che sono state omesse dal diagramma ma sono comunque presenti nel file \texttt{shapes.ttl}. \\ 
    \hline
    Sbml & Ogni file SBML ha un'etichetta con tag \texttt{sbml}, data la sua obbligatorietà ed unicità è possibile costruire grafi SHACL composti da multipli modelli SBML ed esplorarli radicando l'albero in Sbml, è importante specificare che questo nuovo modello composto non sarà legale in SBML e non si dà alcuna garanzia nella fase di riconversione in SBML. Il costrutto Sbml ammette altri attributi oltre quelli noti, siccome in SHACL ho necessità di conoscerne il tipo è stata persa questa possibilità.\\
    \hline
    Model & Rappresenta il modello, se ne può avere più di uno come detto sopra nonostante SBML non lo permetta. \\
    \hline
    Unit & Definisce un'unità di misura definita dall'utente, in SBML sono definite delle unità base (i.e. le unità del SI e altre scelte dagli sviluppatori di SBML) e combinandole opportunamente tra loro è possibile definire nuove unità di misura (e.g l'accelerazione $\frac{m}{s^{2}}$ che altro non è se non $m^{1}s^{-2}$). Nel modello in \texttt{shapes.ttl} le unità base (kind) sono trattate come normalissime unità di misura, in SBML non è concesso avere come attributo kind un'unità di misura che non sia base e questa libertà non genera problemi. \\
    \hline 
    Compartment & Rappresenta un insieme di entità biologiche. \\
    \hline
    Species & Rappresenta un'entità biologica. \\
    \hline
    Parameter & In SBML si possono definire parametri sia locali che globali, il modello presentato in queso progetto non implementa la località quindi i parametri sono sempre globali e in Model l'attributo \texttt{ListOfParameters} ha moltiplicità $[0,n]$ piuttosto che $[0,1]$. \\  
    \hline 
    \multicolumn{2}{c}{Extended SBML} \\
    \hline
    ExternalModelDefinition &  Necessario per importare modelli esterni. \\
    \hline
    ModelDefinition & Questo costrutto fornisce la definizione di un modello. \\ 
    \hline
    Submodel & L'istanza di una ModelDefinition è rappresentata da un Submodel, si ha un modello dentro ad un altro modello. Durante la fase di test per extended SBML non ho usato esempi scaricati da Biomodels perché la gerarchia non veniva rappresentata tramite il costrutto Submodel ma con un attributo \texttt{outer} in Compartment, con il Professor Tronci si è ritenuto fosse meglio attenersi allo standard W3C. \\ 
    \hline
    Port & Una port permette allo sviluppatore di definire come ci si deve interfacciare con un modello, per quanto non siano vincolanti di norma è preferibile seguire le indicazioni dello sviluppatore. \\ 
    \hline
    Deletion & Non è detto che i modelli importati abbiano solo ed esclusivamente componenti desiderabili e con una deletion è possibile ignorare quelli indesiderati. \\
    \hline
    Replacement & Tramite questo costrutto è possibile sostituire una componente con un'altra, ogni riferimento alla prima ora punta alla seconda. A causa di Replacement sono presenti più parser: il primo \texttt{parser.py} esplora il file XML come una lista e associare un Replacement ad un componente risulta estremamente macchinoso se non impossibile, in \texttt{extended\_parser.py} questo problema non si presenta perché il file XML viene esplorato come un albero. \\
    \hline
    SBaseRef & Port, Deletion, Replacement e Submodel utilizzano dei riferimenti, SBaseRef similmente a SBase offre alle proprie sottoclassi degli attributi comuni a tutte. \\
    \hline

    \caption{Modellazione SHACL}
    \label{tab:modellazione}
\end{longtable}

\begin{sidewaysfigure}
    \caption{Modellazione SBML}
    \label{fig:diagram}
    \includegraphics[scale=0.6]{images/diagram.png}
\end{sidewaysfigure}
\clearpage

\section{Parsing da SBML a SHACL}

In questa fase sono stati scritti due parser, di questi \texttt{extended\_parser.py} è la versione finale e corretta. In \texttt{parser.py} si riescono a tradurre senza problemi file in SBML 3.2 ma siccome il file XML viene letto come una lista di etichette risulta macchinoso (ammesso e non concesso sia possibile) fare riferimento all'etichetta padre di una sostituzione o una cancellazione. Il problema non si presenta nel secondo parser dato che la struttura XML viene esplorata come un albero, questa seconda versione è inoltre più breve (444 righe anziché 932), più veloce come si può vedere in tabella ~\ref{tab:performance} ed è più facilmente estendibile. Questo parser infatti prende qualsiasi tag e vi associa i rispettivi attributi - che devono essere noti - al proprio valore; ho comunque imposto dei controlli per evitare questo comportamento dato che avrebbe solo rallentato la fase di verifica.

Il calcolo delle performance è basato sull'esecuzione di \texttt{test.sh} e si fa uso solo di file SBML 3.2 scaricati da Biomodels. Nella sottocartella \texttt{custom}) vi sono file d'esempio forniti direttamente dal W3C in extended SBML e potranno essere usati per il file \texttt{extended\_parser.py}. 

\begin{table}[h!t] 
    \centering
    \begin{longtable}{p{3.3cm}p{2cm}p{1.5cm}p{1.5cm}p{1.5cm}}
        \textbf{File} & \textbf{System (s)} & \textbf{User (s)} & \textbf{Total} & \textbf{CPU} \\
        \hline
        parser.py & 52.90 & 2445.38 & 42:54.54 & 97 \% \\
        extended\_parser.py & 38.07 & 1003.51 & 17:35.19 & 98 \% \\
        \hline
    \end{longtable}
    \caption{Performance}
    \label{tab:performance}
\end{table}

Per il corretto funzionamento del codice è necessario il download del package \textit{rdflib}.

\section{Parsing da SHACL a SBML}
In questa terza e ultima fase si esegue la controprova della precedente ovvero si traduce il file di istanze SHACL ottenuto in un file SBML e ci si attende che venga modellata la stessa conoscenza. Nella cartella \texttt{query} sono presenti tre file:

\begin{itemize}
    \item \texttt{query.py}: Permette di interrogare il modello con query SPARQL, la query deve essere scritta direttamente nel codice perché l'argomento della funzione print varia in base alla query.
    \item \texttt{ttl2sbml.py}: Il parser da SHACL a SBML.
    \item \texttt{ttl2xml}: Converte un file di istanze Turtle in XML, una query e un file XML possono esprimere la stessa conoscenza traducendo una tripla \texttt{<subject> <predicate> <object>} in etichette \texttt{<subject> <predicate> <object/> </predicate> </subject>}.
\end{itemize}

Nella scrittura del parser è risultato necessario poter riottenere la struttura annidata dell'XML che si era persa nella scrittura delle istanze SHACL, per farlo ho definito un albero e dei nodi, nella fase di lettura del file si costruisce gradualmente l'albero. Una volta ottenuto l'albero in questione per scrivere il testo XML basta esplorarlo ricorsivamente ricordandosi di chiudere le etichette aperte una volta terminate le chiamate ai figli. 

L'algoritmo genera la stessa conoscenza dei file di partenza, per SBML 3.2 non ci sono problemi invece per i file nella cartella \texttt{custom} tutti tranne \texttt{MANUAL\_1.xml} \underline{non} superano la verifica SBML perché trattandosi di file d'esempio i riferimenti non sono reali; chiaramente anche l'output di \texttt{ttl2sbml.py} dà risultato negativo, per \texttt{MANUAL\_1.txt} invece si ha lo stesso esito ovvero numerosi warning.

Come detto prima non ho usato esempi presi da Biomodels perché i file trovati con extended SBML implementavano la gerarchia con un attributo \texttt{outer} piuttosto che con i \texttt{submodel} come da documentazione ufficiale.

\section{Commenti e critiche}
Durante lo sviluppo del progetto si è tenuto conto dei seguenti commenti e critiche da parte del Professor Tronci:

\begin{longtable}{p{2cm}p{9cm}}
    \textbf{Data} & \textbf{Descrizione} \\
    \hline
    22/07/20 & Videochiamata con specifica del problema da parte del Professor Tronci. \\
    \hline
    27/07/20 & Prima stesura di una modellazione dei costrutti in SBML, avendo dimenticato di modellare extended SBML mi è stato fatto notare dal Professore e ho risolto, mi è stato anche consegnato il materiale su extended SBML da consultare. \\
    \hline
    28/07/20 & Corretto il punto precedente non avevo implementato deletion e replacement, il Professore ha inoltre consigliato la strategia di testing. \\
    \hline
    31/07/20 & Dopo aver aggiunto replacement e deletion e dopo aver eseguito dei test con risultati positivi è seguita una videochiamata con il Professor Tronci in cui mi è stato indicato di modificare il parser in maniera tale da poter ricevere in input più modelli SBML e di capire se il risultato di una query SPARQL rappresenti lo stesso tipo di conoscenza di un file XML/SBML, così da poter sfruttare questa corrispondenza per eseguire dei controtest. Questa corrispondenza esiste ed è usata spesso sotto il nome di "SPARQL query results xml format". \\
    \hline
    06/08/2020 & Videochiamata con il Professor Tronci in cui si è deciso di comprendere se fosse possibile scrivere un parser da SHACL a SBML e, in caso di risposta affermativa, farlo. \\
    \hline
\end{longtable}

\clearpage
\section{Fonti}
\begin{itemize}
    \item \href{http://sbml.org/Main_Page}{The systems biology markup language.}
    \item \href{https://www.w3.org/TR/rdf-sparql-query/}{Sparql query language for rdf, 2008}.  
    \item \href{https://www.w3.org/TR/rdf-sparql-XMLres/#defn-srd}{Sparql query results xml format (second edition), 2013.}
    \item \href{https://www.w3.org/TR/rdf11-concepts/#dfn-datatype}{Rdf 1.1 concepts and abstract syntax, 2014.}
    \item \href{https://www.w3.org/TR/shacl/}{Shapes constraint language (shacl), 2017.}
    \item \href{http://co.mbine.org/specifications/sbml.level-3.version-2.core.release-2.pdf}{Michael Hucka, Frank T. Bergmann, Claudine Chaouiya, Andreas Drä-ger, Stefan Hoops, Sarah M. Keating, Matthias König, Nicolas Le Novère,Chris J. Myers, Brett G. Olivier, Sven Sahle, James C. Schaff, RahumanSheriff, Lucian P. Smith, Dagmar Waltemath, Darren J. Wilkinson, andFengkai Zhang. The systems biology markup language (sbml): Languagespecification for level 3 version 2 core, 2019.} 
    \item \href{https://authors.library.caltech.edu/50975/1/sbml-comp-version-1-release-3.pdf}{Lucian P. Smith, Stefan Hoops, Martin Ginkel, Ion Moraru, Michael Hucka,Andrew Finney, Chris J. Myers, and Wolfram Liebermeister. Hierarchicalmodel composition, 2013.} 
\end{itemize}

\end{document}